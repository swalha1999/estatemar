# i18n with Next.js 13/14 and App Directory / App Router (an i18next Guide)

**Date:** 02/01/2023  
**Tags:** i18n, i18next, internationalization, l10n, localization, locize, next, next-i18next, react, react-i18next, translation  
**Author:** locize Â© inweso GmbH

At Next.js Conf, the Vercel team announced Next.js 13, which introduced the new app directory / App Router paradigm. This article is also valid for newer Next.js versions like Next.js 14. It includes support for Layouts, Server Components, Streaming, and Support for Data Fetching.

---

## Awesome! Next.js 13 Has Been Released!

It seems pretty fast and lays the foundations to be dynamic without limits.

### Afterthoughts...

This sounds good, but looking more into the app directory / App Router paradigm, it looks like this is a completely new Next.js setup... not really comparable to the old one...

### What Does This Mean Regarding i18n?

Looking at the docs, it seems our old approaches will not work anymore.

**Nice features provided by next-i18next (and other Next.js related i18n modules), like described [here](https://example.com) and [here](https://example.com) are not suited to this new app directory setup.**  
**So you don't need next-i18next anymore!**

---

## A New Approach

In this section, you'll see how we can internationalize the new app directory with the use of i18next, react-i18next, and i18next-resources-to-backend.

```bash
npm install i18next react-i18next i18next-resources-to-backend
```

---

### 1. Folder Structure

Let's start by creating a new folder structure that uses the language as a URL parameterâ€”a so-called dynamic segment:

```
.
â””â”€â”€ app
    â””â”€â”€ [lng]
        â”œâ”€â”€ second-page
        â”‚   â””â”€â”€ page.js
        â”œâ”€â”€ layout.js
        â””â”€â”€ page.js
```

The `app/[lng]/page.js` file could look like this:

```javascript
import Link from "next/link";

export default function Page({ params: { lng } }) {
    return (
        <>
            <h1>Hi there!</h1>
            <Link href={`/${lng}/second-page`}>second page</Link>
        </>
    );
}
```

And the `app/[lng]/second-page/page.js` file could look like this:

```javascript
import Link from "next/link";

export default function Page({ params: { lng } }) {
    return (
        <>
            <h1>Hi from second page!</h1>
            <Link href={`/${lng}`}>back</Link>
        </>
    );
}
```

Lastly, the `app/[lng]/layout.js` file could look like this:

```javascript
import { dir } from "i18next";

const languages = ["en", "de"];

export async function generateStaticParams() {
    return languages.map((lng) => ({ lng }));
}

export default function RootLayout({ children, params: { lng } }) {
    return (
        <html lang={lng} dir={dir(lng)}>
            <head />
            <body>{children}</body>
        </html>
    );
}
```

---

### 2. Language Detection

Now, navigating to `http://localhost:3000/en` or `http://localhost:3000/de` should show something, and also the links to the second page and back should work, but navigating to `http://localhost:3000` will return a 404 error.  
To fix that, we'll create a Next.js middleware and refactor a bit of code:

Let's first create a new file `app/i18n/settings.js`:

```javascript
export const fallbackLng = "en";
export const languages = [fallbackLng, "de"];
```

Then adapt the `app/[lng]/layout.js` file:

```javascript
import { dir } from "i18next";
import { languages } from "../i18n/settings";

export async function generateStaticParams() {
    return languages.map((lng) => ({ lng }));
}

export default function RootLayout({ children, params: { lng } }) {
    return (
        <html lang={lng} dir={dir(lng)}>
            <head />
            <body>{children}</body>
        </html>
    );
}
```

And finally create a `middleware.js` file:

```bash
npm install accept-language
```

```javascript
import { NextResponse } from "next/server";
import acceptLanguage from "accept-language";
import { fallbackLng, languages, cookieName } from "./app/i18n/settings";

acceptLanguage.languages(languages);

export const config = {
    matcher: ["/((?!api|_next/static|_next/image|assets|favicon.ico|sw.js|site.webmanifest).*)"],
};

export function middleware(req) {
    let lng;
    if (req.cookies.has(cookieName)) lng = acceptLanguage.get(req.cookies.get(cookieName).value);
    if (!lng) lng = acceptLanguage.get(req.headers.get("Accept-Language"));
    if (!lng) lng = fallbackLng;

    if (
        !languages.some((loc) => req.nextUrl.pathname.startsWith(`/${loc}`)) &&
        !req.nextUrl.pathname.startsWith("/_next")
    ) {
        return NextResponse.redirect(new URL(`/${lng}${req.nextUrl.pathname}`, req.url));
    }

    if (req.headers.has("referer")) {
        const refererUrl = new URL(req.headers.get("referer"));
        const lngInReferer = languages.find((l) => refererUrl.pathname.startsWith(`/${l}`));
        const response = NextResponse.next();
        if (lngInReferer) response.cookies.set(cookieName, lngInReferer);
        return response;
    }

    return NextResponse.next();
}
```

Navigating to the root path `/` will now check if there's already a cookie with the last chosen language; as a fallback, it will check the Accept-Language header, and the last fallback is the defined fallback language. The detected language will be used to redirect to the appropriate page.

---

### 3. i18n Instrumentation

Let's prepare i18next in the `app/i18n/index.js` file:  
We're not using the i18next singleton here but creating a new instance on each `useTranslation` call, because during compilation everything seems to be executed in parallel. Having a separate instance will keep the translations consistent.

```javascript
import { createInstance } from "i18next";
import resourcesToBackend from "i18next-resources-to-backend";
import { initReactI18next } from "react-i18next/initReactI18next";
import { getOptions } from "./settings";

const initI18next = async (lng, ns) => {
    const i18nInstance = createInstance();
    await i18nInstance
        .use(initReactI18next)
        .use(
            resourcesToBackend(
                (language, namespace) => import(`./locales/${language}/${namespace}.json`)
            )
        )
        .init(getOptions(lng, ns));
    return i18nInstance;
};

export async function useTranslation(lng, ns, options = {}) {
    const i18nextInstance = await initI18next(lng, ns);
    return {
        t: i18nextInstance.getFixedT(lng, Array.isArray(ns) ? ns[0] : ns, options.keyPrefix),
        i18n: i18nextInstance,
    };
}
```

In the `app/i18n/settings.js` file, we'll add the i18next options:

```javascript
export const fallbackLng = "en";
export const languages = [fallbackLng, "de"];
export const defaultNS = "translation";
export const cookieName = "i18next";

export function getOptions(lng = fallbackLng, ns = defaultNS) {
    return {
        supportedLngs: languages,
        fallbackLng,
        lng,
        fallbackNS: defaultNS,
        defaultNS,
        ns,
    };
}
```

Let's prepare some translation files:

```
.
â””â”€â”€ app
    â””â”€â”€ i18n
        â””â”€â”€ locales
            â”œâ”€â”€ en
            â”‚   â”œâ”€â”€ translation.json
            â”‚   â””â”€â”€ second-page.json
            â””â”€â”€ de
                â”œâ”€â”€ translation.json
                â””â”€â”€ second-page.json
```

`app/i18n/locales/en/translation.json`:

```json
{
    "title": "Hi there!",
    "to-second-page": "To second page"
}
```

`app/i18n/locales/de/translation.json`:

```json
{
    "title": "Hallo Leute!",
    "to-second-page": "Zur zweiten Seite"
}
```

`app/i18n/locales/en/second-page.json`:

```json
{
    "title": "Hi from second page!",
    "back-to-home": "Back to home"
}
```

`app/i18n/locales/de/second-page.json`:

```json
{
    "title": "Hallo von der zweiten Seite!",
    "back-to-home": "ZurÃ¼ck zur Hauptseite"
}
```

Now we're ready to use that in our pages...

Server pages can be async; this way, we can await the `useTranslation` response.

`app/[lng]/page.js`:

```javascript
import Link from "next/link";
import { useTranslation } from "../i18n";

export default async function Page({ params: { lng } }) {
    const { t } = await useTranslation(lng);
    return (
        <>
            <h1>{t("title")}</h1>
            <Link href={`/${lng}/second-page`}>{t("to-second-page")}</Link>
        </>
    );
}
```

`app/[lng]/second-page/page.js`:

```javascript
import Link from "next/link";
import { useTranslation } from "../../i18n";

export default async function Page({ params: { lng } }) {
    const { t } = await useTranslation(lng, "second-page");
    return (
        <>
            <h1>{t("title")}</h1>
            <Link href={`/${lng}`}>{t("back-to-home")}</Link>
        </>
    );
}
```

```javascript
import Link from "next/link";
import { useTranslation } from "../i18n";
import { Footer } from "./components/Footer";

export default async function Page({ params: { lng } }) {
    const { t } = await useTranslation(lng);
    return (
        <>
            <h1>{t("title")}</h1>
            <Link href={`/${lng}/second-page`}>{t("to-second-page")}</Link>
            <br />
            <Link href={`/${lng}/client-page`}>{t("to-client-page")}</Link>
            <Footer lng={lng} />
        </>
    );
}
```

...with translation resources:

`app/i18n/locales/en/translation.json`:

```json
{
    "title": "Hi there!",
    "to-second-page": "To second page",
    "to-client-page": "To client page"
}
```

`app/i18n/locales/de/translation.json`:

```json
{
    "title": "Hallo Leute!",
    "to-second-page": "Zur zweiten Seite",
    "to-client-page": "Zur clientseitigen Seite"
}
```

ğŸ‰ğŸ¥³ **Congratulations ğŸŠğŸ**

---
